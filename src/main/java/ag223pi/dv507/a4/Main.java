package ag223pi.dv507.a4;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.reflect.InvocationTargetException;

import org.antlr.v4.gui.Trees;
import org.antlr.v4.runtime.BufferedTokenStream;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.ConsoleErrorListener;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.util.CheckClassAdapter;
import org.objectweb.asm.util.TraceClassVisitor;

public class Main extends ClassLoader implements Opcodes {
	public static void main(String[] args) {
		// Read the input program file; preferably, use the command-line argument
		// provided by the user! (String args[] in main() for Java)
		// Avoiding a hardcoded path specific to your machine is a good practice...
		if (args.length < 1) {
			System.err.println("Input file not provided!");
			System.exit(1);
		}

		// E.g., the user could eventually start this program from the command line as
		// "java -cp lib/*:bin Assignment2StarterCode tests-valid/arithmetic.ofp"
		// and the input path would thus be "tests-valid/arithmetic.ofp"
		String inputPath = args[0];

		// Parse the input program
		System.out.println("\nParsing started for " + inputPath);

		// Use the parser and lexer previously generated by ANTLR for the .g4 file

		OFPParser parser = null;
		OFPParser.ProgramContext root = null;

		// Read and parse the input program while keeping track of parsing errors
		ConsoleErrorListener errorListener = new ConsoleErrorListener();
		try {
			CharStream inputStream = CharStreams.fromFileName(inputPath);
			OFPLexer lexer = new OFPLexer(inputStream);
			parser = new OFPParser(new BufferedTokenStream(lexer));
			parser.addErrorListener(errorListener);
			root = parser.program(); // "program" is the start rule in the .g4 grammar
		} catch (IOException e) {
			e.printStackTrace();
		}

		Trees.inspect(root, parser);

		// Indented tree print using a custom listener
		// Construct Symbol Table
		ParseTreeWalker walker = new ParseTreeWalker();
		SymbolTable listener = new SymbolTable();
		walker.walk(listener, root);

		System.out.println("\n--> START OF ASSIGNMENT 4!");

		// For macOS path:
		// String progName = inputPath.substring(inputPath.lastIndexOf('/') +
		// 1).replaceAll("\\.ofp$", "");
		// For Windows path:
		final String progName = inputPath.substring(inputPath.lastIndexOf('\\') + 1).replaceAll("\\.ofp$", "");
		System.out.println("\nBytecode generation started.");
		// ByteCodeGenerator bcGen = new ByteCodeGenerator(progName,
		// listener.getVariables(), listener.getFunctions(),
		// listener.getGlobalScope());
		ByteCodeGenerator bcGen = new ByteCodeGenerator(progName, listener.getVariables());
		bcGen.visit(root);
		byte[] code = bcGen.toByteArray();
		System.out.println("Bytecode generation ended.");

		File javaOutFile = new File(progName + ".class");
		FileOutputStream fos;
		try {
			fos = new FileOutputStream(javaOutFile);
			fos.write(code);
			fos.close();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		// Output files are saved in the "/example_programs" folder
		System.out.println("\nBytecode saved in: " + javaOutFile);

		System.out.println("\nPrint bytecode:");
		try {
			ClassReader cr = new ClassReader(code);
			ClassVisitor tracer = new TraceClassVisitor(new PrintWriter(System.out));
			ClassVisitor checker = new CheckClassAdapter(tracer, true);
			cr.accept(checker, 0);
		} catch (Exception e) {
			e.printStackTrace();
		}

		System.out.println("\nExecuting bytecode:");
		Main loader = new Main();
		Class<?> exampleClass = loader.defineClass(progName, code, 0, code.length);
		try {
			exampleClass.getMethods()[0].invoke(null, new Object[] { null });
		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException e) {
			e.printStackTrace();
		}
	}

}